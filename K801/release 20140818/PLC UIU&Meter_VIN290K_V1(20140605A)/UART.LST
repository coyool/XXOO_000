C51 COMPILER V9.00   UART                                                                  08/27/2014 17:22:31 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN UART.OBJ
COMPILER INVOKED BY: D:\Program Files\keil4\C51\BIN\C51.EXE UART.c OMF2 BROWSE DEBUG

line level    source

   1          
   2          /*********************************************************************
   3           *                      Uart Task  Module 
   4           *********************************************************************
   5           * FileName:        UATR.c
   6           * Dependencies:    SH99F01.h
   7           *                                      MAIN.h
   8           *                  UART.h
   9           *                  PLT.h
  10           * Company:         Sinowealth Micro Electronics ltd
  11           *
  12           * All rights reserved.
  13           *
  14           * Author           Date         Comment
  15           *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  16           * robbie.zhang    2010.4.13       Version 1.0
  17           ********************************************************************/
  18          #include  <SH99F01.h>
  19          #include  "MAIN.h"
  20          #include  "UART.h"
  21          #include  "PLT.h"
  22          #include "string.h"
  23          
  24          
  25          //UART Parameter
  26          
  27          bit       uart_TI_ready=0;
  28          bit       uart_RI_start=0;
  29          bit       uart_TI_ok=0;         // complete
  30          bit       uart_RI_ok=0;
  31          
  32          UART_TRANS      xdata uart_trans;
  33          
  34          void UartReturn(uchar count);
  35          
  36          
  37          /****************************************************************************
  38           * Function:          void InitUART()
  39           * Input Parameter:   None
  40           * OutPut Parameter:  None
  41           * Return Value:      None
  42           * Description:       Uart Parameter Setting
  43           *                                              
  44           ***************************************************************************/
  45          void InitUART()
  46          {
  47   1          RCLK = 1;               // set timer2 as baud rate clock
  48   1              TCLK = 1;
  49   1      
  50   1              PCON &= 0x0F;       //SMOD = 0 SSTAT = 0;       
  51   1      
  52   1              if (uBaudOption==0)             //选定2.4K
  53   1              {
  54   2                      TH2 = 0xFF;             // 16000/32/(0x10000-0xFF30) = 2.4k
  55   2                      TL2 = 0x30;
C51 COMPILER V9.00   UART                                                                  08/27/2014 17:22:31 PAGE 2   

  56   2                      RCAP2H = 0xFF;  // reload value
  57   2                      RCAP2L = 0x30;
  58   2              }
  59   1              else if (uBaudOption==1)                    
  60   1              {
  61   2                      TH2 = 0xFF;             // 16000/32/(0x10000-0xFF98) = 4.8k
  62   2                      TL2 = 0x98;
  63   2                      RCAP2H = 0xFF;  // reload value
  64   2                      RCAP2L = 0x98;
  65   2              }
  66   1              else if (uBaudOption==2)
  67   1              {
  68   2                      TH2 = 0xFF;             // 16000/32/(0x10000-0xFFCC) = 9.6k
  69   2                      TL2 = 0xCC;
  70   2                      RCAP2H = 0xFF;  // reload value
  71   2                      RCAP2L = 0xCC;
  72   2              }
  73   1              else      // default
  74   1              {
  75   2                      TH2 = 0xFF;             // 16000/32/(0x10000-0xFF30) = 2.4k
  76   2                      TL2 = 0x30;
  77   2                      RCAP2H = 0xFF;  // reload value
  78   2                      RCAP2L = 0x30;
  79   2              }
  80   1      
  81   1              TR2 = 1;                // start timer
  82   1              
  83   1              SADEN = 0;              //address don't care
  84   1              SADDR = 0;
  85   1              SM0_FE = 1;             // 11b~mode3 , 9 bit (8bit+1bit)
  86   1              SM1_RXOV = 1;
  87   1      
  88   1              SM2_TXCOL = 0;  // mode 1
  89   1              REN = 1;                // enable receive
  90   1              ES = 1;         // enable uart interrupt
  91   1        
  92   1          RI = 0;             // initial clear
  93   1          TI = 0;     
  94   1              memset(&uart_trans,0,sizeof(UART_TRANS));       
  95   1              uart_trans.uart_timeout = 0xFFFF;                 
  96   1              return;
  97   1      }
  98          
  99          /****************************************************************************
 100           * Function:          void Uart_Task()
 101           * Input Parameter:   uart_RI_flag, uart_TI_flag
 102           * OutPut Parameter:  transmit_enable
 103           * Return Value:      None
 104           * Description:       Receive data from Serial Port or transmit data to seiral port
 105           *                                              
 106           ***************************************************************************/
 107          void Uart_Task()
 108          {
 109   1      
 110   1              uchar i,length,temp1;
 111   1              bit     uart_check_fail_flag = 0;
 112   1      
 113   1              if(uart_RI_start)               
 114   1              {                                                                                        
 115   2                      while(uart_trans.uart_timeout)    //receive other data
 116   2                      {
 117   3                              if(RI)
C51 COMPILER V9.00   UART                                                                  08/27/2014 17:22:31 PAGE 3   

 118   3                              {                               
 119   4                                      ACC = SBUF;
 120   4                                      if(P==RB8)      // even check
 121   4                                      {
 122   5                                        uart_trans.uart_buf[uart_trans.uart_ptr] = SBUF;
 123   5                                        uart_trans.uart_ptr++;
 124   5                                        uart_trans.uart_timeout = UART_DELAY;                                                                                   
 125   5                                      }
 126   4                                      else
 127   4                                      {
 128   5                                        //uart_trans.uart_timeout = 0;                // quit faster
 129   5                                        uart_check_fail_flag = 1;                               
 130   5                                      }
 131   4      
 132   4                                      RI = 0;
 133   4                              }                       
 134   3                      }
 135   2                      
 136   2                      if(uart_check_fail_flag)
 137   2                      {
 138   3                              uart_RI_ok = 0;         // receive fail
 139   3                              memset(&uart_trans,0,sizeof(UART_TRANS));
 140   3                      }
 141   2                      else
 142   2                      {
 143   3                              uart_RI_ok = 1;         // receive ok
 144   3                              uart_trans.uart_framelen = uart_trans.uart_ptr;         // dummy
 145   3                              uart_trans.uart_ptr = 0;        
 146   3      
 147   3                              // 2014/6/4, add CRC check////////////
 148   3                              for(i=0;i<(uart_trans.uart_framelen+4);i++)
 149   3                              {
 150   4                                      if (uart_trans.uart_buf[i]==0x68)
 151   4                                                break;
 152   4                              }
 153   3                              length = uart_trans.uart_buf[i+9];
 154   3                              if ((length+12)<=uart_trans.uart_framelen)
 155   3                              {
 156   4                                      temp1 = UartCheckSum(&uart_trans.uart_buf[i],length+10);                // L + 10 byte  (include 0x68)
 157   4                                      //if (temp != uart_trans.uart_buf[i+length+11])                 // CRC
 158   4                                      if (temp1 != uart_trans.uart_buf[i+length+10])                  // bug, 2014/6/4        (start from index 0)
 159   4                                      {
 160   5                                              uart_RI_ok = 0;         // receive fail
 161   5                                              memset(&uart_trans,0,sizeof(UART_TRANS));
 162   5                                              //uart_trans.uart_timeout = 0xFFFF;             // modify,2014/6/4      
 163   5                                      }
 164   4                              }
 165   3                              else
 166   3                              {
 167   4                                      uart_RI_ok = 0;         // receive fail
 168   4                                      memset(&uart_trans,0,sizeof(UART_TRANS));
 169   4                                      //uart_trans.uart_timeout = 0xFFFF;             // modify, 2014/6/4                             
 170   4                              }
 171   3                              /////////////////////////////////////// 
 172   3      
 173   3                              
 174   3                                                      
 175   3                      }
 176   2                      uart_check_fail_flag = 0;
 177   2                      uart_RI_start=0;                                
 178   2                      uart_trans.uart_timeout = 0xFFFF;
 179   2                      ES = 1;         // care, uart timeout, enable ES
C51 COMPILER V9.00   UART                                                                  08/27/2014 17:22:31 PAGE 4   

 180   2                      // not enable ES
 181   2              }
 182   1      
 183   1              else if(uart_TI_ready)                          //return uart data to other device
 184   1              {
 185   2                      ES=0;           // dummy
 186   2                      
 187   2                      TI = 0;         // dummy
 188   2                      RI = 0;
 189   2      
 190   2      
 191   2      //         // 2014/3/21, UIU
 192   2      ////            for(i=0;i<(uart_trans.uart_framelen+4);i++)
 193   2      ////            {
 194   2      ////                    if (plt_trans.plt_buf[i]==0x68)
 195   2      ////                      break;
 196   2      ////            }
 197   2      ////            if (memcmp(&plt_trans.plt_buf[i+1],meter_local_addr,6)==0)              // address match
 198   2      ////            {
 199   2      //                      for(i=0;i<uart_trans.uart_framelen;i++)         
 200   2      //                              UartReturn(plt_trans.plt_buf[i]);
 201   2      //
 202   2      //                      uart_idle_timeout = 0;     // 2014/3/21, must update after trans ok
 203   2      ////            }
 204   2      
 205   2                      // 2014/5/27, enable again
 206   2                      for(i=0;i<(uart_trans.uart_framelen+4);i++)
 207   2                      {
 208   3                              if (plt_trans.plt_buf[i]==0x68)
 209   3                                break;
 210   3                      }
 211   2                      if (memcmp(&plt_trans.plt_buf[i+1],meter_local_addr,6)==0)              // address match
 212   2                      {
 213   3                              for(i=0;i<uart_trans.uart_framelen;i++)         
 214   3                                      UartReturn(plt_trans.plt_buf[i]);
 215   3      
 216   3                      // 2014/6/5
 217   3                           uart_tx_idle_timeout = 0;     // 2014/3/21, must update after trans ok
 218   3                      }
 219   2      
 220   2                                                                                                      
 221   2                      uart_TI_ok = 1;
 222   2                      uart_TI_ready = 0;                              
 223   2                                      
 224   2                      ES=1;
 225   2              }
 226   1              return;
 227   1      }
 228          
 229          /****************************************************************************
 230           * Function:          void UartReturn(uchar dat)
 231           * Input Parameter:   uart data
 232           * OutPut Parameter:  None
 233           * Return Value:      None
 234           * Description:       transmit data by serial port
 235           *                                              
 236           ***************************************************************************/
 237          void UartReturn(uchar dat)               
 238          {               
 239   1                      uint Uart_Delay = 0XFFFF;       
 240   1      
 241   1                      ACC = dat;
C51 COMPILER V9.00   UART                                                                  08/27/2014 17:22:31 PAGE 5   

 242   1                      TB8 = P;        // even check    第9数据位 写入奇偶校验位
 243   1                      SBUF = dat;
 244   1                      while(!TI)
 245   1                      {
 246   2                              Uart_Delay--;
 247   2                              if(Uart_Delay==0)
 248   2                              break;
 249   2                      }
 250   1                      TI=0;
 251   1                      return;
 252   1      }
 253          
 254          uchar UartCheckSum(uchar *buf, uchar len)
 255          {
 256   1              uchar k,sum=0;
 257   1      
 258   1              for (k=0;k<len;k++)
 259   1                 sum+=buf[k];
 260   1              return sum;
 261   1      }
 262          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    535    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     94    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       5
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4       1
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
