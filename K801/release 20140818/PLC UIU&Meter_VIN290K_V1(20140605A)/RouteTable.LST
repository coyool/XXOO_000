C51 COMPILER V9.00   ROUTETABLE                                                            08/18/2014 17:15:12 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE ROUTETABLE
OBJECT MODULE PLACED IN RouteTable.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE RouteTable.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /*********************************************************************
   2           *
   3           *             RouteTable access routines 
   4           *
   5           *********************************************************************
   6           * FileName:        RouteTable.c
   7           * Dependencies:    Compiler.h
   8           * Processor:       SH99F01
   9           * Complier:        Keil C51 v9.00
  10           * Company:         Sinowealth Electronic, Inc.
  11           *
  12           * Software License Agreement
  13           *
  14           * This software is owned by Sinowealth Electronic Inc. ("Sinowealth") 
  15           * and is supplied to you for use exclusively as described in the 
  16           * associated software agreement.  This software is protected by 
  17           * software and other intellectual property laws.  Any use in 
  18           * violation of the software license may subject the user to criminal 
  19           * sanctions as well as civil liability.  Copyright 2009 Sinowealth
  20           * Electronic Inc.  All rights reserved.
  21           *
  22           * This software is provided "AS IS."  SINOWEALTH DISCLAIMS ALL 
  23           * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
  24           * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
  25           * INFRINGEMENT.  Sinowealth shall in no event be liable for special, 
  26           * incidental, or consequential damages.
  27           *
  28           *
  29           * Author               Date           Comment
  30           *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  31           * Ellie Fan            2010/7/9           Original   
  32           * Joseph Zhou          2011/3/21          Modify                                 
  33           ********************************************************************/
  34          
  35          
  36          #include  <SH99F01.h>
  37          #include  "MAIN.h"
  38          #include  "SSP.h"
  39          #include  "RouteTable.h"
  40          #include  "string.h"
  41          
  42          
  43          //MASTER¸ô¥Ñªí,  size = 11
  44          typedef struct
  45          {
  46                  uchar client_SN[6];          //CLIENT§Ç¦C¸¹
  47                  uchar net_ID;                //CLIENTºôµ¸¦a§}
  48                  uchar relay;                 //¤¤Ä~¯Å¼Æ
  49                  uchar RA;                    //³Ì¦Z¤@¬q¤¤Ä~
  50                  uchar BACKUP_RA;             //³Ì¦Z¤@¬q³Æ¥÷¤¤Ä~  
  51              uchar link;                  //¤Jºô¦¨¥\¼Ð§Ó
  52          }ROUTE_ITEM;
  53          
  54          uchar   client_size;
  55          
C51 COMPILER V9.00   ROUTETABLE                                                            08/18/2014 17:15:12 PAGE 2   

  56          
  57          /*********************************************************************************************************
             -******************
  58           * Function:           void InitRouteTable()
  59           * Input Parameter:    None
  60           * OutPut Parameter:   None
  61           * Return Value:       None
  62           * Description:        This function  Initializes the Concetrator RouteTable(clear all the Routetable info
             -rmation and route table size) 
  63           *********************************************************************************************************
             -********************/   
  64          void InitRouteTable()                 //±NEEROM°Ï°ì¥þ³¡À¿°£
  65          {       
  66   1              uchar  index = 0;    
  67   1              while(index<PAGES)
  68   1              {                    
  69   2                      SSP_Erase(index);               
  70   2                      index++; 
  71   2              }
  72   1      }
  73          
  74          void WriteRouteTable(uint dest, uchar *src, uchar len)
  75          {
  76   1              uchar  dat;
  77   1              uchar  index;
  78   1              index = 0;
  79   1              FLASHCON = 0x01;
  80   1              while(index<len)
  81   1              {
  82   2                      dat = src[index];
  83   2                      SSP_Write(dest, dat);
  84   2                      dest++;
  85   2                      index++;
  86   2              }
  87   1              FLASHCON = 0x00;
  88   1      }
  89          
  90          
  91          /*********************************************************************************************************
             -********************
  92           * Function:           Address_Mapping(uint route_item_index)
  93           * Input Parameter:    route_item_index       -¸ô¥Ñªí±ø¥Ø¯Á¤Þ­È                                          
  94           * OutPut Parameter:   None
  95           * Return Value:       ªð¦^route_item_index±ø¥Ø¹ïÀ³¶µªºª«²z¦sÀx¦a§}
  96           * Description:        ¸Ó¨ç¼Æ¥Î¨ÓÀò¨úroute_item_index±ø¥Ø¹ïÀ³¶µªºª«²z¦sÀx¦a§}
  97           *********************************************************************************************************
             -********************/
  98          uint Address_Mapping(uchar route_item_index)
  99          {
 100   1              return (route_item_index%ROUTE_ITEM_PER_PAGE)*sizeof(ROUTE_ITEM)+(route_item_index/ROUTE_ITEM_PER_PAGE)*P
             -AGE_SIZE;                                        //physical index
 101   1      }
 102             
 103          
 104          uchar RouteTable_GetItem(uchar addr)        //±o¨ì¯S©wnetID¹ïÀ³ªº¯Á¤Þ¸¹
 105          {
 106   1              uchar index = 0;
 107   1              uint physical_addr;
 108   1              uchar ID;
 109   1              FLASHCON = 0x01;
 110   1              while(index<client_size)
 111   1              {
C51 COMPILER V9.00   ROUTETABLE                                                            08/18/2014 17:15:12 PAGE 3   

 112   2                      physical_addr = Address_Mapping(index);
 113   2                      ID = SSP_Read(physical_addr+6); //CBYTE[physical_addr+6];
 114   2                      if(ID==addr)
 115   2                      {
 116   3                              return index;
 117   3                      }
 118   2                      ++index;
 119   2              }
 120   1              FLASHCON = 0x00;
 121   1              return 0xFF;
 122   1      }
 123          
 124          
 125          uchar RouteTable_GetItem_SN(uchar *client_SN)        //±o¨ì¯S©wSN¹ïÀ³ªº¯Á¤Þ¸¹
 126          {
 127   1              uchar index = 0;
 128   1              uint physical_addr;
 129   1              uchar client_SN_temp[6];
 130   1              FLASHCON = 0x01;
 131   1              while(index<client_size)
 132   1              {
 133   2                      physical_addr = Address_Mapping(index);
 134   2                      RouteTable_GetSN(index, client_SN_temp);
 135   2                      if(!memcmp(client_SN_temp,client_SN,6))
 136   2                      {
 137   3                              return index;
 138   3                      }
 139   2                      ++index;
 140   2              }
 141   1              FLASHCON = 0x00;
 142   1              return 0xFF;
 143   1      }
 144          
 145          
 146          
 147          void RouteTable_GetSN(uchar route_item_index, uchar* client_SN)   //±qeeprom¤¤Åª¨ú¬Y¤@¯Á¤Þ¸¹¹ïÀ³ªºSN
 148          {
 149   1               uint data physical_addr;
 150   1               physical_addr = Address_Mapping(route_item_index);
 151   1      
 152   1               FLASHCON = 0x01;
 153   1               *client_SN     = SSP_Read(physical_addr);              //CBYTE[physical_addr];
 154   1               *(client_SN+1) = SSP_Read(physical_addr+1);    //CBYTE[physical_addr+1];
 155   1               *(client_SN+2) = SSP_Read(physical_addr+2);    //CBYTE[physical_addr+2];
 156   1               *(client_SN+3) = SSP_Read(physical_addr+3);    //CBYTE[physical_addr+3];
 157   1               *(client_SN+4) = SSP_Read(physical_addr+4);    //CBYTE[physical_addr+4];
 158   1               *(client_SN+5) = SSP_Read(physical_addr+5);            //CBYTE[physical_addr+5];
 159   1               FLASHCON = 0x00;
 160   1           return;
 161   1      }
 162          
 163          
 164          uchar RouteTable_GetID(uchar route_item_index)                                  //±qeeprom¤¤Åª¨ú¬Y¤@¯Á¤Þ¸¹¹ïÀ³ªºnetID
 165          {
 166   1               uint  physical_addr;
 167   1               uchar ID;
 168   1               physical_addr =  Address_Mapping(route_item_index) + 6;
 169   1      
 170   1               FLASHCON = 0x01;
 171   1               ID  = SSP_Read(physical_addr);         //CBYTE[physical_addr];
 172   1               FLASHCON = 0x00;   
 173   1               return ID;
C51 COMPILER V9.00   ROUTETABLE                                                            08/18/2014 17:15:12 PAGE 4   

 174   1      }
 175          
 176          
 177          
 178          uchar RouteTable_GetRelay(uchar route_item_index)                               //±qeeprom¤¤Åª¨ú¬Y¤@¯Á¤Þ¸¹¹ïÀ³ªº¤¤Ä~¯Å¼Æ
 179          {
 180   1              uint  physical_addr;
 181   1              uchar relay;
 182   1      
 183   1              physical_addr = Address_Mapping(route_item_index) + 7;
 184   1              FLASHCON = 0x01;
 185   1              relay = SSP_Read(physical_addr);        //CBYTE[physical_addr];
 186   1              FLASHCON = 0x00;
 187   1              return  relay;
 188   1      }
 189          
 190          
 191          
 192          uchar RouteTable_GetRA(uchar route_item_index)                                  //±qeeprom¤¤Åª¨ú¬Y¤@¯Á¤Þ¸¹¹ïÀ³ªº¤÷¸`ÂI
 193          {
 194   1              uint   physical_addr;
 195   1              uchar  route;
 196   1              
 197   1              physical_addr = Address_Mapping(route_item_index) + 8;
 198   1              FLASHCON = 0x01;
 199   1              route = SSP_Read(physical_addr);        //CBYTE[physical_addr];
 200   1          FLASHCON = 0x00;
 201   1              return route;
 202   1      }
 203          
 204          
 205          
 206          uchar RouteTable_GetBACKUPRA(uchar route_item_index)                    //±qeeprom¤¤Åª¨ú¬Y¤@¯Á¤Þ¸¹¹ïÀ³ªº³Æ¥Î¤÷¸`ÂI
 207          {
 208   1              uint  physical_addr;
 209   1              uchar  route;
 210   1              
 211   1              physical_addr = Address_Mapping(route_item_index) + 9;
 212   1              FLASHCON = 0x01;
 213   1              route = SSP_Read(physical_addr);        //CBYTE[physical_addr];
 214   1          FLASHCON = 0x00;
 215   1              return route;
 216   1      }
 217          
 218          
 219          
 220          uchar RouteTable_GetLink(uchar route_item_index)                                //±qeeprom¤¤Åª¨ú¬Y¤@¯Á¤Þ¸¹¹ïÀ³ªºLink«H®§
 221          {
 222   1              uint  physical_addr;
 223   1              uchar link;
 224   1              
 225   1              physical_addr = Address_Mapping(route_item_index) + 10;
 226   1              FLASHCON = 0x01;
 227   1              link = SSP_Read(physical_addr);         //CBYTE[physical_addr];
 228   1          FLASHCON = 0x00;
 229   1              return link;
 230   1      }
 231          
 232          
 233          
 234          
 235          void RouteTable_LoadItem(uchar route_item_index, uchar* client_SN, uchar netID)      //²Ä¤@¦¸§âªí®æ¥[¸ü¶i¥
C51 COMPILER V9.00   ROUTETABLE                                                            08/18/2014 17:15:12 PAGE 5   

             -h
 236          {       
 237   1           uint  physical_addr;
 238   1               uchar src[7];
 239   1               physical_addr = Address_Mapping(route_item_index);
 240   1           src[0] = *client_SN;
 241   1               src[1] = *(client_SN+1);
 242   1               src[2] = *(client_SN+2);
 243   1               src[3] = *(client_SN+3);
 244   1               src[4] = *(client_SN+4);
 245   1               src[5] = *(client_SN+5);
 246   1               src[6] = netID;
 247   1           WriteRouteTable(physical_addr, src, 7);
 248   1      }
 249          
 250          
 251          
 252          //§ó·s¸ô¥Ñªí¨C¤@¶µ¸ô¥Ñ«H®§
 253          void RouteTable_UpDateItem(uchar route_item_index, uchar netID, uchar relay, uchar route, uchar backup_rou
             -te, uchar link)  
 254          {       
 255   1              uchar src[5];
 256   1              src[0] = netID;
 257   1              src[1] = relay;
 258   1              src[2] = route;
 259   1              src[3] = backup_route;
 260   1              src[4] = link;
 261   1              SSP_Erase(PAGE_BKUP);
 262   1              SSP_CopyPage(route_item_index/ROUTE_ITEM_PER_PAGE,PAGE_BKUP,0,(route_item_index%ROUTE_ITEM_PER_PAGE)*size
             -of(ROUTE_ITEM)+5);
 263   1              WriteRouteTable((route_item_index%ROUTE_ITEM_PER_PAGE)*sizeof(ROUTE_ITEM)+PAGE_BKUP*PAGE_SIZE+6,src,5);
 264   1              SSP_CopyPage(route_item_index/ROUTE_ITEM_PER_PAGE,PAGE_BKUP,((route_item_index%ROUTE_ITEM_PER_PAGE)+1)*si
             -zeof(ROUTE_ITEM),ROUTE_ITEM_PER_PAGE*sizeof(ROUTE_ITEM)-1);   
 265   1              SSP_Erase(route_item_index/ROUTE_ITEM_PER_PAGE);
 266   1              SSP_CopyPage(PAGE_BKUP,route_item_index/ROUTE_ITEM_PER_PAGE,0,ROUTE_ITEM_PER_PAGE*sizeof(ROUTE_ITEM)-1);
 267   1      }
 268          
 269          
 270          //§ó·s¸ô¥ÑªíLink«H®§
 271          void RouteTable_ChangeLink(uchar route_item_index,uchar link)  
 272          {       
 273   1              uchar src[1];
 274   1              src[0] = link;
 275   1              SSP_Erase(PAGE_BKUP);
 276   1              SSP_CopyPage(route_item_index/ROUTE_ITEM_PER_PAGE,PAGE_BKUP,0,(route_item_index%ROUTE_ITEM_PER_PAGE)*size
             -of(ROUTE_ITEM)+9);
 277   1              WriteRouteTable((route_item_index%ROUTE_ITEM_PER_PAGE)*sizeof(ROUTE_ITEM)+PAGE_BKUP*PAGE_SIZE+10,src,1);
 278   1              SSP_CopyPage(route_item_index/ROUTE_ITEM_PER_PAGE,PAGE_BKUP,((route_item_index%ROUTE_ITEM_PER_PAGE)+1)*si
             -zeof(ROUTE_ITEM),ROUTE_ITEM_PER_PAGE*sizeof(ROUTE_ITEM)-1);   
 279   1              SSP_Erase(route_item_index/ROUTE_ITEM_PER_PAGE);
 280   1              SSP_CopyPage(PAGE_BKUP,route_item_index/ROUTE_ITEM_PER_PAGE,0,ROUTE_ITEM_PER_PAGE*sizeof(ROUTE_ITEM)-1);
 281   1      }
 282          
 283          
 284          
 285          
 286          
 287          uchar RouteTable_CMPSNNETID(uchar* client_SN, uchar netID)
 288          {
 289   1              uchar index = 0;
 290   1              uchar netID_temp;
 291   1              uchar client_SN_temp[6];
C51 COMPILER V9.00   ROUTETABLE                                                            08/18/2014 17:15:12 PAGE 6   

 292   1              uchar status = 0;
 293   1              uchar route_temp;
 294   1              while(index<client_size)
 295   1              {
 296   2                      RouteTable_GetSN(index, client_SN_temp); 
 297   2                      netID_temp = RouteTable_GetID(index);
 298   2                      route_temp = RouteTable_GetRA(index);
 299   2                      if(!memcmp(client_SN_temp,client_SN,6))
 300   2                              status |= 0X01;
 301   2                      if(netID_temp==netID)
 302   2                              status |= 0X02;
 303   2                      ++index;
 304   2              }
 305   1              return status;
 306   1      }
 307          
 308          
 309          
 310          uchar RouteTable_ROUTECHECK(uchar status,uchar netID,uchar route)
 311          {
 312   1              uchar index = 0;
 313   1              uchar route_status = 3;
 314   1              uchar route_temp;
 315   1              uchar netID_temp;
 316   1              uchar link;
 317   1              if((status==3)||(status==1))
 318   1              {
 319   2                      while(index<client_size)
 320   2                      {
 321   3                              netID_temp = RouteTable_GetID(index);
 322   3                              route_temp = RouteTable_GetRA(index);
 323   3                              link = RouteTable_GetLink(index);       
 324   3                              if(netID_temp==netID)
 325   3                              {
 326   4                                      if((route_temp==route)&&(link==1))
 327   4                                      {
 328   5                                              route_status = 2;
 329   5                                              break;
 330   5                                      }
 331   4                              }
 332   3                              index++;
 333   3                      }
 334   2              }
 335   1              if(route_status!=2)
 336   1              {       
 337   2                      if(route==0XFF)
 338   2                              route_status = 1;
 339   2                      else
 340   2                      {
 341   3                              index = 0;
 342   3                              while(index<client_size)
 343   3                              {
 344   4                                      netID_temp = RouteTable_GetID(index);   
 345   4                                      link = RouteTable_GetLink(index);
 346   4                                      if((netID_temp==route)&&(link==1))
 347   4                                      {
 348   5                                              route_status = 1;
 349   5                                              break;
 350   5                                      }       
 351   4                                      index++;
 352   4                              }
 353   3                      }
C51 COMPILER V9.00   ROUTETABLE                                                            08/18/2014 17:15:12 PAGE 7   

 354   2              }
 355   1              return route_status;
 356   1      }
 357          
 358          
 359          
 360          
 361          void RouteTable_ReadItem(uchar route_item_index, uchar *frame)      //²Ä¤@¦¸§âªí®æ¥[¸ü¶i¥h
 362          {       
 363   1              uchar index = 0; 
 364   1              uint  physical_addr;
 365   1              physical_addr = Address_Mapping(route_item_index);
 366   1              FLASHCON = 0x01;
 367   1              while(index<9)
 368   1              {
 369   2                      frame[index] = SSP_Read(physical_addr+index);   //CBYTE[physical_addr+index];
 370   2                      index++;
 371   2              }
 372   1              FLASHCON = 0x00;
 373   1              return;
 374   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1112    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1      80
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
