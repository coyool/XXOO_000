C51 COMPILER V9.00   PLT                                                                   09/16/2014 17:52:59 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE PLT
OBJECT MODULE PLACED IN ..\..\PLT.obj
COMPILER INVOKED BY: D:\Program Files\keil4\C51\BIN\C51.EXE PLT.c OMF2 BROWSE DEBUG OBJECT(..\..\PLT.obj)

line level    source

   1          #include  "SH99F01.h"
   2          #include  "MAIN.h"
   3          #include  "UART.h"
   4          #include  "PLT.h"
   5          
   6          /*********************************************************************
   7           *
   8           *                 PLT Access Routines 
   9           *
  10           *********************************************************************
  11           * FileName:        PLT.c
  12           * Dependencies:    
  13           *                                      string.h
  14           *                                      SH99F01.h
  15           *                                      MAIN.h
  16           *                  UART.h
  17           *                  PLT.h
  18           * Company:         Sinowealth Micro Electronics ltd
  19           *
  20           * All rights reserved.
  21           *
  22           * Author               Date           Comment
  23           *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  24           * Robbie Zhang        2010/7/9            Original  
  25           * joseph.zhou          2012.12.17         Version 1.2
  26           ********************************************************************/
  27          
  28          //#include "absacc.h"
  29          #include "string.h"
  30          //#include "stdlib.h"
  31          #include  "SH99F01.h"
  32          #include  "MAIN.h"
  33          #include  "UART.h"
  34          #include  "PLT.h"
  35          
  36          
  37          uint xdata Timer_count=0;
  38          
  39          
  40          
  41          
  42          PLT_TRANS       xdata plt_trans;
  43          
  44          //////Input Variable
  45          ///Start transmit
  46          bit     transmit_enable = 0;
  47          
  48          /////Output Variable
  49          bit             rx_ok_flag = 0;
  50          bit             tx_ok_flag = 0;
  51          uchar   rssi = 0;
  52          
  53          
  54          /////Other Variable
  55          bit             rx_flag = 0;
C51 COMPILER V9.00   PLT                                                                   09/16/2014 17:52:59 PAGE 2   

  56          bit             tx_flag = 0;
  57          bit             zc_flag = 0;
  58          bit             pd_flag = 0;
  59          bit             fa_flag = 0;
  60          bit             nb_flag = 0;
  61          bit             once_ok = 0;
  62          bit             carrier_stage = 0;
  63          
  64          uchar   rx_count = 0;
  65          uchar   nb_repeat = 0;
  66          
  67          bit     en_zc_delay = 0;
  68          bit     en_delay_half = 0;
  69          bit     en_delay_flag = 0;
  70          bit     en_frame_delay = 0;
  71          bit             transmit_continue = 0; 
  72          bit     frame_transmit_ready = 0;
  73          
  74          uchar   zc_delay_cnt = 0;
  75          
  76          
  77          uint   xdata  plt_trans_timeout = 0xFFFF;       
  78          uint   xdata  plt_recev_timeout = 0xFFFF;
  79          
  80          
  81          uchar xdata  plt_buf_trans[FRAME_LENGTH+2];     // UART data buffer / PLT data buffer / APP data buffer
  82          
  83          
  84          uchar bdata bit_data;
  85          sbit bit0 = bit_data^0;
  86          sbit bit1 = bit_data^1;
  87          sbit bit2 = bit_data^2;
  88          sbit bit3 = bit_data^3;
  89          sbit bit4 = bit_data^4;
  90          sbit bit5 = bit_data^5;
  91          sbit bit6 = bit_data^6;
  92          sbit bit7 = bit_data^7;
  93          
  94          void InitWB(); 
  95          void InitNBZC(); 
  96          void InitNB();
  97          
  98          
  99          void Mode_SCSF();
 100          void Mode_DMZC();
 101          
 102          
 103          void PLTSetting();
 104          void SetPLT(uchar adr,uchar dat);
 105          void WriteTXBUF(uchar *frame);
 106          void ReadRXBUF(uchar *frame); 
 107          void Zc_Delay();
 108          //uint CRC16(uchar n, uchar *buf);
 109          uchar  CheckSum8(uchar n, uchar *buf);
 110          uchar GetRSSI();
 111          
 112          
 113          /*********************************************************************************************
 114           * Function:           void InitPLT(void)
 115           * Input Parameter:    None
 116           * OutPut Parameter:   None
 117           * Return Value:       None
C51 COMPILER V9.00   PLT                                                                   09/16/2014 17:52:59 PAGE 3   

 118           * Description:        This function  Initializes Registers and variables of PLT Module 
 119          **********************************************************************************************/
 120          void InitPLT()
 121          {       
 122   1              memset(&plt_trans,0,sizeof(PLT_TRANS)); 
 123   1      
 124   1              plt_trans.plt_timeout = 0xFFFF;
 125   1                      
 126   1              transmit_enable = 0;
 127   1              tx_flag = 0;
 128   1              rx_flag = 0;
 129   1              tx_ok_flag = 0;
 130   1              rx_ok_flag = 0;
 131   1              pd_flag = 0;
 132   1              fa_flag = 0;    
 133   1              zc_flag = 0;
 134   1              transmit_continue = 0;
 135   1              en_zc_delay = 0;
 136   1              en_delay_half = 0;
 137   1              once_ok = 0;
 138   1              rx_count = 0;
 139   1              nb_flag=0;
 140   1              nb_repeat=0;
 141   1              carrier_stage=0;
 142   1      
 143   1              plt_trans_timeout = 0xFFFF;     
 144   1          plt_recev_timeout = 0xFFFF;
 145   1      
 146   1              PLTSetting();
 147   1                                                      
 148   1              return;
 149   1      }
 150          
 151          
 152          void PLTSetting()
 153          {
 154   1              if (bModeOption)
 155   1              {
 156   2                      if(nb_flag)
 157   2                              InitNBZC();
 158   2                      else 
 159   2                              InitWB();
 160   2              }
 161   1              else
 162   1                      InitNB();
 163   1      }
 164          
 165          /***********************************************************************************************
 166           * Function:          void PLTTask(void)
 167           * Input Parameter:   None
 168           * OutPut Parameter:  None
 169           * Return Value:      None
 170           * Description:       This function acts as a task of PLT Module. Main application must call
 171           *                    this function repeatdly to ensure the PLT transmit and receive data on time.        
             -                  
 172          ************************************************************************************************/
 173          void PLTTask()
 174          {       
 175   1              if (bModeOption)
 176   1                      Mode_DMZC();
 177   1              else
 178   1                      Mode_SCSF();
C51 COMPILER V9.00   PLT                                                                   09/16/2014 17:52:59 PAGE 4   

 179   1      }
 180          
 181          
 182          /**********************************************************************************************
 183           * Function:          void InitWB()
 184           * Input parameter:   None 
 185           * OutPut parameter:  None
 186           * Return Value:      None 
 187           * Description:       This funcition configure the register of PLT Module(WideBand, Enable FEC)           
             -    
 188           ***********************************************************************************************/
 189          
 190          void InitWB()
 191          {
 192   1              PLOCK = 0xA5;       //UnLock
 193   1              PLCON |= 0x4;           //SRST
 194   1      
 195   1              PLCON = 0xE8;           //Enable PLT/CRC/FEC/ RSSIEN, 
 196   1      
 197   1              SetPLT(UMR1,0x00); 
 198   1      
 199   1              SetPLT(UMR2,FRAME_LENGTH); // SetPLT()  special process
 200   1      
 201   1              if (bChanOption)
 202   1              {
 203   2                      SetPLT(UMR3,0x43); // bypass ABPF,DBPF, vincom input
 204   2                      SetPLT(TXFC,0x5C); // 290KHz
 205   2                      SetPLT(RXFC,0x5C); 
 206   2              }
 207   1              else                                      //ybz!!!
 208   1              {
 209   2                      SetPLT(UMR3,0x41); // bypass ABPF,DBPF, vin input
 210   2      //              SetPLT(TXFC,0x1F); // 100KHz
 211   2      //              SetPLT(RXFC,0x1F); 
 212   2                      SetPLT(TXFC,0x5C); // 290KHz, 2014/2/24
 213   2                      SetPLT(RXFC,0x5C); 
 214   2              }
 215   1      
 216   1              SetPLT(SSCI,0x80); // 
 217   1              SetPLT(SSCQ,0x00); // 
 218   1              SetPLT(TACQ,0x10); // default
 219   1              SetPLT(TFA,0x0A);  // default   
 220   1          CLKCON = 0x00;      // PLTCLK = SYSCLK
 221   1              PLOCK = 0x5A;   //Lock    
 222   1      
 223   1      }
 224          
 225          
 226          
 227          
 228          
 229          /**********************************************************************************************
 230           * Function:          void InitNB()
 231           * Input parameter:   None 
 232           * OutPut parameter:  None
 233           * Return Value:      None 
 234           * Description:       This funcition configure the register of PLT Module(NarrowBand Normal Speed)        
             -       
 235           ***********************************************************************************************/
 236          void InitNB()
 237          {
 238   1              PLOCK = 0xA5;        //UnLock
C51 COMPILER V9.00   PLT                                                                   09/16/2014 17:52:59 PAGE 5   

 239   1              PLCON |= 0x4;           //SRST
 240   1              PLCON = 0xE8;           //Enable PLT/CRC/FEC/ RSSIEN, FACPR=0   
 241   1              
 242   1              SetPLT(UMR1,0x80);  //Narrow band, normal
 243   1      
 244   1      
 245   1              SetPLT(UMR2,FRAME_LENGTH); // 20 bytes, care SetPLT() special                   
 246   1      
 247   1              if (bChanOption)
 248   1              {
 249   2                      SetPLT(UMR3,0x43); // bypass ABPF,DBPF, vincom input
 250   2                      SetPLT(TXFC,0x5C); // 290KHz
 251   2                      SetPLT(RXFC,0x5C); 
 252   2              }
 253   1              else
 254   1              {
 255   2                      SetPLT(UMR3,0x41); // bypass ABPF,DBPF, vin input
 256   2      //              SetPLT(TXFC,0x1F); // 100KHz
 257   2      //              SetPLT(RXFC,0x1F); 
 258   2                      SetPLT(TXFC,0x5C); // 290KHz, 2014/2/24
 259   2                      SetPLT(RXFC,0x5C); 
 260   2              }
 261   1              SetPLT(NACQCT,0x06); 
 262   1      
 263   1              // 2014/5/27
 264   1              SetPLT(NACQDT,0x90);            // central 160 (0xA0) A2013-12-17 modify
 265   1              SetPLT(NACQUT,0xB0);
 266   1      
 267   1              PLOCK = 0x5A;   //Lock  
 268   1      
 269   1              return;
 270   1      }
 271          /**********************************************************************************************
 272           * Function:          void InitZERO()
 273           * Input parameter:   None 
 274           * OutPut parameter:  None
 275           * Return Value:      None 
 276           * Description:       This funcition configure the register of PLT Module(SSLP)               
 277           ***********************************************************************************************/
 278          void InitNBZC()
 279          {
 280   1              PLOCK = 0xA5;       //UnLock PLT REG
 281   1              PLCON |= 0x4;           //SRST   PLT模块软复位，自动解锁
 282   1              PLCON = 0x88;           //Enable PLT/RSSIEN, Disable CRC/FEC FACPR = 0  
 283   1      
 284   1              SetPLT(UMR1,0xC0);      // Narrowband, Low Speed (超短帧调制 低速)
 285   1      
 286   1              SetPLT(UMR2,SSLP_LENGTH);       // 4 bytes per fraction
 287   1              if (bChanOption)
 288   1              {
 289   2                      SetPLT(UMR3,0x43); // bypass ABPF,DBPF, vincom input   0 dB
 290   2                      SetPLT(TXFC,0x5C); // 290KHz
 291   2                      SetPLT(RXFC,0x5C); 
 292   2              }
 293   1              else
 294   1              {
 295   2                      SetPLT(UMR3,0x41); // bypass ABPF,DBPF, vin input          0 dB 
 296   2      //              SetPLT(TXFC,0x1F); // 100KHz
 297   2      //              SetPLT(RXFC,0x1F); 
 298   2                      SetPLT(TXFC,0x5C); // 290KHz, 2014/2/24
 299   2                      SetPLT(RXFC,0x5C); 
 300   2              }
C51 COMPILER V9.00   PLT                                                                   09/16/2014 17:52:59 PAGE 6   

 301   1              SetPLT(NACQCT,0x06);   // 同步参数 默认值  ??
 302   1      
 303   1              // 2014/5/27
 304   1              SetPLT(NACQDT,0x90);            // central 160 (0xA0) A2013-12-17 modify       ??
 305   1              SetPLT(NACQUT,0xB0);        //                                                                                  ??
 306   1      
 307   1              PLOCK = 0x5A;           //Lock  
 308   1              return;
 309   1      }
 310          
 311          
 312          
 313          /**********************************************************************************************
 314           * Function:          void  Mode_NBSF()
 315           * Input parameter:   None
 316           * OutPut parameter:  None
 317           * Return Value:      None 
 318           * Description:       Single Frame Mode              
 319           ***********************************************************************************************/
 320          
 321          void Mode_SCSF()
 322          {
 323   1              if(transmit_enable)      
 324   1              {
 325   2                      if(((PLCON&0x01)==0x00)&&(!tx_flag))
 326   2                      {
 327   3                                              
 328   3                              WriteTXBUF(plt_buf_trans);                      
 329   3      
 330   3                              if (RXINT||rx_flag)     // dummy
 331   3                              {
 332   4                              RXINT = 0;
 333   4                                      rx_flag = 0;
 334   4                              }
 335   3                              
 336   3                              PLCON |= 0x01;  
 337   3      
 338   3                              if (RXINT||rx_flag)     // dummy
 339   3                              {
 340   4                              RXINT = 0;
 341   4                              rx_flag = 0;
 342   4                              }
 343   3                              plt_trans_timeout = FRAME_DURATION_NBSF_TX;
 344   3      
 345   3                      }
 346   2              else if (tx_flag)
 347   2              {                               
 348   3                              tx_flag = 0;
 349   3      //                      tx_ok_flag = 1;
 350   3                              transmit_enable = 0;
 351   3      //                      plt_trans_timeout = 0xFFFF;     
 352   3      //                      memset(plt_buf_trans,0,FRAME_LENGTH);                                                                                           
 353   3      
 354   3                              plt_trans_timeout = 10;
 355   3              }       
 356   2              }
 357   1              else          
 358   1              {
 359   2                      if(rx_flag)
 360   2                      {                          
 361   3                              rx_flag = 0;
 362   3      
C51 COMPILER V9.00   PLT                                                                   09/16/2014 17:52:59 PAGE 7   

 363   3                              ReadRXBUF(plt_buf_trans);
 364   3                              rx_ok_flag = 1;
 365   3                              pd_flag = 0;
 366   3                              fa_flag = 0;
 367   3                              plt_recev_timeout = 0xFFFF;
 368   3                      }       
 369   2                      else if((!pd_flag)&&RXPD)
 370   2                      {
 371   3                              pd_flag = 1;
 372   3                              plt_recev_timeout = FRAME_DURATION_NBSF_RX;
 373   3                      }       
 374   2                                      
 375   2                  else if ((!fa_flag)&&RXFA)  
 376   2                  {       
 377   3                      fa_flag = 1;    
 378   3                              rssi = GetRSSI();
 379   3                  }
 380   2      
 381   2                  if(!RXPD)
 382   2                              pd_flag = 0;    
 383   2                  if (!RXFA)  
 384   2                      fa_flag = 0;                            
 385   2              }
 386   1      
 387   1              if (!plt_recev_timeout)
 388   1              {               
 389   2                      InitPLT();              // dummy
 390   2                      plt_recev_timeout = 0xFFFF;
 391   2              }
 392   1              
 393   1              if (!plt_trans_timeout)
 394   1              {
 395   2                              tx_ok_flag = 1;
 396   2                              transmit_enable = 0;
 397   2                              plt_trans_timeout = 0xFFFF;     
 398   2                              //memset(plt_buf_trans,0,FRAME_LENGTH); 
 399   2              }
 400   1      
 401   1              return;
 402   1      }
 403          
 404          
 405          
 406          
 407          
 408          
 409          /**********************************************************************************************
 410           * Function:          void  Mode_DMZC()
 411           * Input parameter:   None
 412           * OutPut parameter:  None
 413           * Return Value:      None 
 414           * Description:       WideBand&SSLP           
 415           ***********************************************************************************************/
 416          void Mode_DMZC()
 417          {
 418   1              uchar i;        
 419   1              uint    crc_temp = 0;
 420   1              uchar   PltDataTemp0 = 0;
 421   1              uchar   PltDataTemp1 = 0;
 422   1              uint    crc_temp00 = 0; 
 423   1      
 424   1              if(transmit_enable)
C51 COMPILER V9.00   PLT                                                                   09/16/2014 17:52:59 PAGE 8   

 425   1              {               
 426   2                      if(!nb_flag)
 427   2                      {                       
 428   3                              if (tx_flag)            
 429   3                              {
 430   4                                      tx_flag = 0;                                    
 431   4                                      transmit_continue = 0;  // dummy                
 432   4                                      nb_flag = 1;              
 433   4      
 434   4                                      IE1 = 0;                         // drop  tx_timeout_count
 435   4                                      TCON |= 0x04;
 436   4                                      zc_flag = 0;
 437   4                                      EX1 = 1;        
 438   4                              }
 439   3      
 440   3                              else
 441   3                              {
 442   4                                      if((PLCON&0x01)==0x00)                  
 443   4                                      {       
 444   5                                              nb_flag = 0;    // dummy                                
 445   5                                              PLTSetting();                                   
 446   5      
 447   5                                              WriteTXBUF(plt_buf_trans);
 448   5                                              if (RXINT||rx_flag)             // dummy
 449   5                                              {
 450   6                                                      RXINT = 0;
 451   6                                                      rx_flag = 0;
 452   6                                              }
 453   5                                              PLCON |= 0x01;   
 454   5                                              if (RXINT||rx_flag)                     // dummy
 455   5                                              {
 456   6                                                      RXINT = 0;
 457   6                                                      rx_flag = 0;
 458   6                                              }
 459   5                                              plt_trans_timeout = FRAME_DURATION_DMZC_TX;     
 460   5                                      }
 461   4                              }
 462   3                      }
 463   2                      else 
 464   2                      {                       
 465   3                              if(zc_flag)
 466   3                              {
 467   4                                      zc_flag = 0;
 468   4                                      en_zc_delay = 1;
 469   4                                      Zc_Delay();
 470   4                                      nb_repeat = 0;          // dummy                
 471   4                                      //crc_temp = CRC16(FRAME_LENGTH,plt_buf_trans);
 472   4      
 473   4                                      //plt_buf_trans[FRAME_LENGTH] = crc_temp;
 474   4                                      //plt_buf_trans[FRAME_LENGTH+1] = crc_temp>>8;
 475   4      
 476   4                                      plt_buf_trans[FRAME_LENGTH] = CheckSum8(FRAME_LENGTH,plt_buf_trans);    // modify checksum
 477   4      
 478   4                                      PLTSetting();                           
 479   4                              }
 480   3      
 481   3                              if(tx_flag)
 482   3                              {
 483   4                                      tx_flag = 0;
 484   4                                      if(nb_repeat>=NB_CNT)
 485   4                                      {
 486   5                                              plt_trans_timeout = FRAME_DURATION_DMZC_TXTAIL;                 // care, can't return directly
C51 COMPILER V9.00   PLT                                                                   09/16/2014 17:52:59 PAGE 9   

 487   5                                              transmit_enable = 0;
 488   5                                                                      
 489   5                                      }
 490   4                              }
 491   3                              else if(((PLCON&0x01)==0x00)&&transmit_continue)                // PLCON&0x01 dummy                     
 492   3                              {                                       
 493   4                                      for(i=0;i<SSLP_LENGTH;i++)
 494   4                                      {
 495   5                                              PLADR1= i;
 496   5                                              PLBUF = plt_buf_trans[i+SSLP_LENGTH*nb_repeat];
 497   5                              }                               
 498   4                                      nb_repeat++;
 499   4      
 500   4                                      if (RXINT||rx_flag)                     
 501   4                                      {
 502   5                                              RXINT = 0;
 503   5                                              rx_flag = 0;
 504   5                                      }
 505   4                                      PLCON |= 0x01; 
 506   4                                      if (RXINT||rx_flag)                             
 507   4                                      {
 508   5                                              RXINT = 0;
 509   5                                              rx_flag = 0;
 510   5                                      }
 511   4                                      transmit_continue = 0;  
 512   4                                  en_delay_half = 1;
 513   4                                      Zc_Delay();
 514   4                              }                       
 515   3                       }
 516   2              }
 517   1              else          
 518   1              {
 519   2                  if(plt_recev_timeout==0)
 520   2              {       
 521   3                              rx_ok_flag = 0;                 
 522   3                  if (once_ok)
 523   3                      rx_ok_flag = 1;                                                         
 524   3                  else
 525   3                  {
 526   4                              if(rx_count>=ZERO_TOTAL_LEN)
 527   4                              {
 528   5                                      //crc_temp = CRC16(FRAME_LENGTH,(uchar*)(&(plt_buf_trans[0])));
 529   5                                      //PltDataTemp0 = plt_buf_trans[FRAME_LENGTH];        //CRCL
 530   5                                  //PltDataTemp1 = plt_buf_trans[FRAME_LENGTH+1];      //CRCH
 531   5          
 532   5                                      //if(((PltDataTemp1<<8)|PltDataTemp0)==crc_temp)
 533   5      
 534   5                                      PltDataTemp0 = plt_buf_trans[FRAME_LENGTH];        //CRCL
 535   5                                  PltDataTemp1 = CheckSum8(FRAME_LENGTH,(uchar*)(&(plt_buf_trans[0])));
 536   5                                              if (PltDataTemp0==PltDataTemp1)   
 537   5                                               rx_ok_flag = 1;                                                                                                                                
 538   5                              }                
 539   4                  }                           
 540   3                  rx_count = 0;  // reset                     
 541   3                              once_ok = 0;    
 542   3                              fa_flag = 0;    // modify
 543   3                              pd_flag = 0;
 544   3                          nb_flag = 0;                                
 545   3                              PLTSetting();     // care, will modify frame_duration again
 546   3                  carrier_stage = 0;
 547   3                              plt_recev_timeout = 0xFFFF;                                                                                             
 548   3                      }
C51 COMPILER V9.00   PLT                                                                   09/16/2014 17:52:59 PAGE 10  

 549   2      
 550   2                      if(rx_flag)
 551   2                      {   
 552   3                              if (!once_ok)
 553   3                              {
 554   4                                  if (!nb_flag)               // WB ok
 555   4                              {       
 556   5                                              ReadRXBUF(plt_buf_trans);                                       // debug, bypass WB receive
 557   5                                          once_ok = 1;                                                                                        
 558   5                                      }                               // NB stage
 559   4                                      else
 560   4                                      {                                     
 561   5                                              if(rx_count<ZERO_TOTAL_LEN)             
 562   5                                              {
 563   6                                      for(i=0;i<SSLP_LENGTH;i++)
 564   6                                              {
 565   7                                                              PLADR1 = i;
 566   7                                                              plt_buf_trans[rx_count] = PLBUF;
 567   7                                                              rx_count++;
 568   7                                      }
 569   6                                              }               
 570   5                          } 
 571   4                              }       
 572   3                              rx_flag = 0; 
 573   3                      }
 574   2              
 575   2                      else if((!pd_flag)&&RXPD)
 576   2                      {
 577   3                              pd_flag = 1; 
 578   3                                      
 579   3                              if(!carrier_stage)  
 580   3                  {   
 581   4                                      carrier_stage = 1;        // first entrance, WB stage
 582   4      
 583   4                                      plt_recev_timeout = FRAME_DURATION_DMZC_RX;                                     
 584   4                                      once_ok = 0;            // dummy
 585   4                                      nb_flag = 0;            // dummy
 586   4                                      rx_count = 0;           // dummy
 587   4      
 588   4                                      fa_flag = 0;
 589   4                              }
 590   3                                                      
 591   3                      }
 592   2      
 593   2                      else if ((!fa_flag)&&RXFA&&(!nb_flag))  
 594   2                  {       
 595   3                      fa_flag = 1;    // modify, only entrance once
 596   3      
 597   3                              rssi = GetRSSI();
 598   3                  } 
 599   2      
 600   2                  if((!RXPD)&&pd_flag)        
 601   2                      {               
 602   3                              pd_flag = 0;
 603   3      
 604   3                              if (!nb_flag)
 605   3                              {
 606   4                                      en_delay_flag = 1;
 607   4                                      Timer_count = 0;
 608   4                              }       
 609   3                      }
 610   2      
C51 COMPILER V9.00   PLT                                                                   09/16/2014 17:52:59 PAGE 11  

 611   2                      if (frame_transmit_ready)
 612   2                      {
 613   3                              frame_transmit_ready = 0;
 614   3                              nb_flag = 1;
 615   3                              PLTSetting();                   
 616   3                      }
 617   2              }
 618   1              if (plt_trans_timeout==0)               
 619   1              {
 620   2                      plt_trans_timeout = 0xFFFF;             
 621   2                      nb_repeat = 0;
 622   2                      nb_flag = 0;
 623   2                      zc_flag = 0;    // dummy
 624   2                      PLTSetting();
 625   2                      transmit_continue = 0;
 626   2                      transmit_enable = 0;
 627   2                      en_delay_half = 0;
 628   2                      en_zc_delay = 0;        //dummy
 629   2                      tx_ok_flag = 1;         // ok, care, avoid flow halt    
 630   2      
 631   2                      //memset(plt_buf_trans,0,FRAME_LENGTH+2);               // dummy                                                
 632   2              }
 633   1      }
 634          
 635          
 636          
 637          
 638          
 639          /***********************************************************************************************
 640           * Function:          void PLT_TimerTask(void)
 641           * Input Parameter:   None
 642           * OutPut Parameter:  None
 643           * Return Value:      None
 644           * Description:       This function deal with the timer Task of PLT Module. it is called in Timer0 
 645                                            interrupt routine to make sure the timer task of PLT is run on time.
 646          ************************************************************************************************/
 647          void PLT_TimerTask()
 648          {
 649   1              // reserve
 650   1              if(en_delay_flag&&(Timer_count>=FRAME_INTERVAL))  
 651   1              {
 652   2                      en_delay_flag = 0;
 653   2                      frame_transmit_ready = 1;
 654   2              }
 655   1                      
 656   1              if(en_zc_delay&&(Timer_count>=zc_delay_cnt))                     
 657   1              {
 658   2                      en_zc_delay = 0;
 659   2                      transmit_continue = 1;          
 660   2              }
 661   1              if(en_delay_half&&(Timer_count>=zc_delay_cnt))          //half period of AC
 662   1              {
 663   2                      en_delay_half = 0;
 664   2                      transmit_continue = 1;
 665   2              }
 666   1              
 667   1      
 668   1              if(plt_trans_timeout && plt_trans_timeout!=0xFFFF)                      //receive flow timeout
 669   1                       --plt_trans_timeout; 
 670   1              if(plt_recev_timeout && plt_recev_timeout!=0xFFFF)                      //receive flow timeout
 671   1                       --plt_recev_timeout; 
 672   1      
C51 COMPILER V9.00   PLT                                                                   09/16/2014 17:52:59 PAGE 12  

 673   1              if(plt_trans.plt_timeout && plt_trans.plt_timeout!=0xFFFF)                      //receive flow timeout
 674   1                       --plt_trans.plt_timeout; 
 675   1              if(uart_trans.uart_timeout && uart_trans.uart_timeout!=0xFFFF)                   
 676   1                       --uart_trans.uart_timeout; 
 677   1      }
 678          
 679          
 680          /*******************************************************************************
 681           * Function:          bit  Transmit()
 682           * Input parameter:   None
 683           * OutPut parameter:  None
 684           * Return Value:      None
 685           * Description:       This funcition set the flag to start transmit              
 686           *******************************************************************************/
 687          bit Transmit(void)
 688          {
 689   1              if(RXINT||(PLCON&0x1)||TXINT)
 690   1              {
 691   2                      RXINT = 0;      // dummy
 692   2                      TXINT = 0;
 693   2                      return 0;       
 694   2              }   
 695   1              else 
 696   1              {
 697   2                      transmit_enable = 1; 
 698   2                      plt_trans_timeout = 0xFFFF;             
 699   2                      tx_flag = 0;    
 700   2                      tx_ok_flag = 0;         
 701   2                      return 1;  
 702   2              }
 703   1      }
 704          
 705          /*******************************************************************************
 706           * Function:          void WriteTXBUF(uchar *frame)
 707           * Input parameter:   frame    -pointer to to the  begining of tramsmit data packet
 708           * OutPut parameter:  None
 709           * Return Value:      None
 710           * Description:       This funcition write the data to TXBUF              
 711           *******************************************************************************/
 712          void WriteTXBUF(uchar *frame)
 713          {
 714   1              uchar i; 
 715   1              for(i=0; i<FRAME_LENGTH; i++)
 716   1              {
 717   2                      PLADR1 = i;        
 718   2                      PLBUF = *(frame++);
 719   2              }
 720   1      }
 721          
 722          /*******************************************************************************
 723           * Function:          void ReadRXBUF(uchar *frame)
 724           * Input parameter:   frame    -pointer to to the  begining of tramsmit data packet
 725           * OutPut parameter:  None
 726           * Return Value:      None
 727           * Description:       This funcition read the data from RXBUF              
 728           *******************************************************************************/
 729          void ReadRXBUF(uchar *frame)
 730          {
 731   1              uchar i; 
 732   1              for(i=0; i<FRAME_LENGTH; i++)
 733   1              {
 734   2                      PLADR1 = i;        
C51 COMPILER V9.00   PLT                                                                   09/16/2014 17:52:59 PAGE 13  

 735   2                      *(frame++) = PLBUF;
 736   2              }
 737   1      }
 738          
 739          /*******************************************************************************
 740           * Function:          void SetPLT(uchar adr, uchar dat)
 741           * Input parameter:   adr, dat
 742           * OutPut parameter:  None
 743           * Return Value:      None
 744           * Description:       This funcition is to set one PLT register              
 745           *******************************************************************************/
 746          void SetPLT(uchar adr, uchar dat)
 747          {
 748   1              
 749   1              PLADR2 = adr;
 750   1              if(PLADR2==UMR2)
 751   1              {
 752   2                      PLREG = (dat/11)<<6;     //FEC 有关
 753   2                      PLREG = PLREG + dat;
 754   2              }
 755   1              else 
 756   1                      PLREG = dat;
 757   1      }
 758          /*******************************************************************************
 759           * Function:          uchar GetRSSI()
 760           * Input parameter:   None
 761           * OutPut parameter:  None
 762           * Return Value:      None
 763           * Description:       This funcition is to Calculate RSSI of receive Signal              
 764           *******************************************************************************/
 765          uchar GetRSSI()
 766          {       
 767   1          uchar m_nRssiCount=0;
 768   1          uint  m_nRssiSum=0;
 769   1              uint  m_nRssiTemp=0;
 770   1              uchar m_nRssiH=0;
 771   1              uchar m_nRssiL=0;       
 772   1              
 773   1              ADCON = 0x80;            // Open ADC
 774   1              ADT = 0xA8;                  //Tad=16*tsys, Tsamp=(8+1)*Tad, Ttotal=(12+9)*Tad=21*16*tsys= 0.021ms (47.6KHz)
 775   1          while(m_nRssiCount<8)        //the average of 8 samples
 776   1          {
 777   2              ADCON |= 0x01;
 778   2              while((ADCON&0x01)==0x01);
 779   2                      PLADR2=PLRSSIH;
 780   2                      m_nRssiH=PLREG;
 781   2                      PLADR2=PLRSSIL;
 782   2                      m_nRssiL=PLREG;
 783   2                      m_nRssiTemp = 63+47*(ADDH*1.65-m_nRssiH)/(m_nRssiL-m_nRssiH);    // correct
 784   2                      m_nRssiSum+=m_nRssiTemp;
 785   2      
 786   2              ADCON&=0x0BF;              
 787   2              m_nRssiCount++;
 788   2          }
 789   1              ADCON &= 0x7F;          // Close ADC     (for low power)
 790   1      
 791   1          return (255-(m_nRssiSum>>3));        // reverse RSSI curve    
 792   1      }
 793          
 794          /*******************************************************************************
 795           * Function:          uint  CRC16(uchar n, uchar *buf)
 796           * Input parameter:   n---FrameLength, *buf--the point to the buginning of data packet 
C51 COMPILER V9.00   PLT                                                                   09/16/2014 17:52:59 PAGE 14  

 797           * OutPut parameter:  None
 798           * Return Value:      None
 799           * Description:       This funcition is to Calculate  CRC16 check code            
 800           *******************************************************************************/
 801          
 802          //uint  CRC16(uchar n, uchar *buf)
 803          //{
 804          //    uchar i, j;
 805          //      uint crc;
 806          //      crc = 0x0A5A5;         
 807          //      
 808          //      if (n>30)       n %= 30;        // n<=30
 809          //      for(j=0;j<n;j++)
 810          //      {
 811          //          bit_data = *(buf++);        
 812          //              
 813          //              for(i=0;i<8;i++)
 814          //              {
 815          //                      crc=crc<<1;
 816          //                      if(bit0^CY)
 817          //                              crc=(crc^0x8004)|0x0001;
 818          //                      bit_data=bit_data>>1;
 819          //              }
 820          //      }
 821          //      return crc;
 822          //}
 823          
 824          uchar  CheckSum8(uchar n, uchar *buf)
 825          {
 826   1          uchar i;
 827   1              uchar checksum;
 828   1                 
 829   1              checksum = 0;
 830   1              if (n>31)       n = 31;         
 831   1              for(i=0;i<n;i++)
 832   1              {
 833   2                  checksum += *(buf++);                       
 834   2              }
 835   1              return checksum;
 836   1      }
 837          
 838          
 839          /*******************************************************************************
 840           * Function:          void Zc_Delay()
 841           * Input parameter:   None
 842           * OutPut parameter:  None
 843           * Return Value:      None
 844           * Description:       This funcition is to set timeout parameter in 50Hz or in 60Hz            
 845           *******************************************************************************/
 846          void Zc_Delay()
 847          {                       
 848   1              Timer_count = 0;        
 849   1              if(bFreqOption)                                         //AC: 50Hz
 850   1              {
 851   2                      if(en_zc_delay)                                 //delay 7.5ms(10-2.5) after zero cross detect
 852   2                      {
 853   3                              TL0 = -MS_05;
 854   3                              TH0 = (-MS_05)>>8;
 855   3                              //zc_delay_cnt = 8;
 856   3                              zc_delay_cnt = 18;                 // delay 17.5ms
 857   3                      }
 858   2                      else if(en_delay_half)                  //delay 10ms(half period of AC)
C51 COMPILER V9.00   PLT                                                                   09/16/2014 17:52:59 PAGE 15  

 859   2                  {
 860   3                              TL0     = -TIMER0;    
 861   3                              TH0     = (-TIMER0)>>8;
 862   3                              zc_delay_cnt = 10;
 863   3                      
 864   3                      }
 865   2              }
 866   1              else                                                            // AC: 60Hz
 867   1              {
 868   2                      if(en_zc_delay)                                 //delay 5.9ms(8.3-2.4) after zero cross detect
 869   2                      {
 870   3                              //TL0 = -MS_09;
 871   3                              //TH0 = (-MS_09)>>8;
 872   3                              //zc_delay_cnt = 6;
 873   3      
 874   3                              TL0 = -MS_02;
 875   3                              TH0 = (-MS_02)>>8;
 876   3                              zc_delay_cnt = 15;                 // delay 14.2ms
 877   3                      }
 878   2                      else if(en_delay_half)                  //delay 8.3ms(half period of AC)
 879   2                      {
 880   3                              TL0 = -MS_03;
 881   3                              TH0 = (-MS_03)>>8;
 882   3                              zc_delay_cnt = 9;
 883   3                      }
 884   2              }       
 885   1              return;
 886   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1634    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    132    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      5      21
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     17    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
